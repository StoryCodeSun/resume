import{g as i,I as e,c as n,l as t,B as a,n as o}from"./tsparticles-engine-1e3d91c8.js";function s(i,e,t,a,o,s){!function(i,e){var t;const a=i.options,o=a.move.path;if(!o.enable)return;if(i.lastPathTime<=i.pathDelay)return void(i.lastPathTime+=e.value);const s=null==(t=i.pathGenerator)?void 0:t.generate(i,e);s&&i.velocity.addTo(s);o.clamp&&(i.velocity.x=n(i.velocity.x,-1,1),i.velocity.y=n(i.velocity.y,-1,1));i.lastPathTime-=i.pathDelay}(i,s);const c=i.gravity,l=(null==c?void 0:c.enable)&&c.inverse?-1:1;o&&t&&(i.velocity.x+=o*s.factor/(60*t)),(null==c?void 0:c.enable)&&t&&(i.velocity.y+=l*(c.acceleration*s.factor)/(60*t));const r=i.moveDecay;i.velocity.multTo(r);const p=i.velocity.mult(t);(null==c?void 0:c.enable)&&a>0&&(!c.inverse&&p.y>=0&&p.y>=a||c.inverse&&p.y<=0&&p.y<=-a)&&(p.y=l*a,t&&(i.velocity.y=p.y/t));const y=i.options.zIndex,v=(1-i.zIndexFactor)**y.velocityRate;p.multTo(v);const{position:d}=i;d.addTo(p),e.vibrate&&(d.x+=Math.sin(d.x*Math.cos(d.y)),d.y+=Math.cos(d.y*Math.sin(d.x)))}class c{constructor(){this._initSpin=i=>{const e=i.container,n=i.options.move.spin;if(!n.enable)return;const o=n.position??{x:50,y:50},s={x:o.x/100*e.canvas.size.width,y:o.y/100*e.canvas.size.height},c=i.getPosition(),l=t(c,s),r=a(n.acceleration);i.retina.spinAcceleration=r*e.retina.pixelRatio,i.spin={center:s,direction:i.velocity.x>=0?"clockwise":"counter-clockwise",angle:i.velocity.angle,radius:l,acceleration:i.retina.spinAcceleration}}}init(i){const e=i.options.move.gravity;i.gravity={enable:e.enable,acceleration:a(e.acceleration),inverse:e.inverse},this._initSpin(i)}isEnabled(i){return!i.destroyed&&i.options.move.enable}move(n,t){var c,l;const r=n.options,p=r.move;if(!p.enable)return;const y=n.container,v=y.retina.pixelRatio,d=function(i){return i.slow.inRange?i.slow.factor:1}(n),u=((c=n.retina).moveSpeed??(c.moveSpeed=a(p.speed)*v))*y.retina.reduceFactor,x=(l=n.retina).moveDrift??(l.moveDrift=a(n.options.move.drift)*v),m=o(r.size.value)*v,h=u*(p.size?n.getRadius()/m:1)*d*(t.factor||1)/2,f=n.retina.maxSpeed??y.retina.maxSpeed;p.spin.enable?function(i,e){const n=i.container;if(!i.spin)return;const t={x:"clockwise"===i.spin.direction?Math.cos:Math.sin,y:"clockwise"===i.spin.direction?Math.sin:Math.cos};i.position.x=i.spin.center.x+i.spin.radius*t.x(i.spin.angle),i.position.y=i.spin.center.y+i.spin.radius*t.y(i.spin.angle),i.spin.radius+=i.spin.acceleration;const a=Math.max(n.canvas.size.width,n.canvas.size.height);i.spin.radius>a/2?(i.spin.radius=a/2,i.spin.acceleration*=-1):i.spin.radius<0&&(i.spin.radius=0,i.spin.acceleration*=-1),i.spin.angle+=e/100*(1-i.spin.radius/a)}(n,h):s(n,p,h,f,x,t),function(n){const t=n.initialPosition,{dx:a,dy:o}=i(t,n.position),s=Math.abs(a),c=Math.abs(o),{maxDistance:l}=n.retina,r=l.horizontal,p=l.vertical;if(r||p)if((r&&s>=r||p&&c>=p)&&!n.misplaced)n.misplaced=!!r&&s>r||!!p&&c>p,r&&(n.velocity.x=n.velocity.y/2-n.velocity.x),p&&(n.velocity.y=n.velocity.x/2-n.velocity.y);else if((!r||s<r)&&(!p||c<p)&&n.misplaced)n.misplaced=!1;else if(n.misplaced){const i=n.position,a=n.velocity;r&&(i.x<t.x&&a.x<0||i.x>t.x&&a.x>0)&&(a.x*=-e()),p&&(i.y<t.y&&a.y<0||i.y>t.y&&a.y>0)&&(a.y*=-e())}}(n)}}async function l(i,e=!0){await i.addMover("base",(()=>new c),e)}export{l};
