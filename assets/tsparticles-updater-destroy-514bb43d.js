import{A as t,L as o,O as s,k as e,F as i,a1 as l,p as r,a2 as n,B as c,M as a,U as d}from"./tsparticles-engine-1e3d91c8.js";class f{load(o){o&&(void 0!==o.bottom&&(this.bottom=t(o.bottom)),void 0!==o.left&&(this.left=t(o.left)),void 0!==o.right&&(this.right=t(o.right)),void 0!==o.top&&(this.top=t(o.top)))}}class h extends o{constructor(){super(),this.value=3}}class u extends o{constructor(){super(),this.value={min:4,max:9}}}class p{constructor(){this.count=1,this.factor=new h,this.rate=new u,this.sizeOffset=!0}load(t){t&&(void 0!==t.color&&(this.color=s.create(this.color,t.color)),void 0!==t.count&&(this.count=t.count),this.factor.load(t.factor),this.rate.load(t.rate),this.particles=e(t.particles,(t=>i({},t))),void 0!==t.sizeOffset&&(this.sizeOffset=t.sizeOffset),t.colorOffset&&(this.colorOffset=this.colorOffset??{},void 0!==t.colorOffset.h&&(this.colorOffset.h=t.colorOffset.h),void 0!==t.colorOffset.s&&(this.colorOffset.s=t.colorOffset.s),void 0!==t.colorOffset.l&&(this.colorOffset.l=t.colorOffset.l)))}}class v{constructor(){this.bounds=new f,this.mode="none",this.split=new p}load(t){t&&(t.mode&&(this.mode=t.mode),t.bounds&&this.bounds.load(t.bounds),this.split.load(t.split))}}function y(o,s,e,i){const r=e.options.destroy;if(!r)return;const f=r.split,h=n(o,s,e.options),u=l(f.factor),p=e.getFillColor();f.color?h.color.load(f.color):f.colorOffset&&p?h.color.load({value:{hsl:{h:p.h+c(f.colorOffset.h??0),s:p.s+c(f.colorOffset.s??0),l:p.l+c(f.colorOffset.l??0)}}}):h.color.load({value:{hsl:e.getFillColor()}}),h.move.load({center:{x:e.position.x,y:e.position.y,mode:"precise"}}),a(h.size.value)?h.size.value/=u:(h.size.value.min/=u,h.size.value.max/=u),h.load(i);const v=f.sizeOffset?t(-e.size.value,e.size.value):0,y={x:e.position.x+d(v),y:e.position.y+d(v)};return s.particles.addParticle(y,h,e.group,(o=>!(o.size.value<.5)&&(o.velocity.length=d(t(e.velocity.length,o.velocity.length)),o.splitCount=(e.splitCount??0)+1,o.unbreakable=!0,setTimeout((()=>{o.unbreakable=!1}),500),!0)))}class O{constructor(t,o){this.engine=t,this.container=o}init(t){const o=this.container,s=t.options.destroy;if(!s)return;t.splitCount=0;const e=s.bounds;t.destroyBounds||(t.destroyBounds={});const{bottom:i,left:l,right:r,top:n}=e,{destroyBounds:a}=t,d=o.canvas.size;i&&(a.bottom=c(i)*d.height/100),l&&(a.left=c(l)*d.width/100),r&&(a.right=c(r)*d.width/100),n&&(a.top=c(n)*d.height/100)}isEnabled(t){return!t.destroyed}loadOptions(t,...o){t.destroy||(t.destroy=new v);for(const s of o)t.destroy.load(null==s?void 0:s.destroy)}particleDestroyed(t,o){if(o)return;const s=t.options.destroy;s&&"split"===s.mode&&function(t,o,s){const e=s.options.destroy;if(!e)return;const i=e.split;if(i.count>=0&&(void 0===s.splitCount||s.splitCount++>i.count))return;const n=l(i.rate),c=r(i.particles);for(let l=0;l<n;l++)y(t,o,s,c)}(this.engine,this.container,t)}update(t){if(!this.isEnabled(t))return;const o=t.getPosition(),s=t.destroyBounds;s&&(void 0!==s.bottom&&o.y>=s.bottom||void 0!==s.left&&o.x<=s.left||void 0!==s.right&&o.x>=s.right||void 0!==s.top&&o.y<=s.top)&&t.destroy()}}async function m(t,o=!0){await t.addParticleUpdater("destroy",(o=>new O(t,o)),o)}export{m as l};
